import { Observable } from 'rxjs';
export declare type Undux<State extends object> = {
    [K in keyof State]: {
        key: K;
        previousValue: State[K];
        value: State[K];
    };
};
/**
 * Public Store interface. When you want to reference the Store type,
 * this is the type to use.
 */
export interface Store<State extends object> {
    get<K extends keyof State>(key: K): State[K];
    set<K extends keyof State>(key: K): (value: State[K]) => void;
    on<K extends keyof State>(key: K): Observable<State[K]>;
    onAll(): Observable<Undux<State>[keyof State]>;
    getState(): Readonly<State>;
}
/**
 * Immutable snapshot of the current store state. One StoreSnapshot per
 * StoreDefinition is usually alive at a time.
 */
export declare class StoreSnapshot<State extends object> implements Store<State> {
    private state;
    private storeDefinition;
    constructor(state: State, storeDefinition: StoreDefinition<State>);
    get<K extends keyof State>(key: K): State[K];
    set<K extends keyof State>(key: K): (value: State[K]) => void;
    on<K extends keyof State>(key: K): Observable<State[K]>;
    onAll(): Observable<Undux<State>[keyof State]>;
    getState(): Readonly<State>;
}
/**
 * Immutable edge from StoreSnapshot to a component that consumes it
 * via withStore(). We use it to keep track of which fields a consumer
 * reads from, so that we can improve performance by only subscribing
 * to those fields.
 */
export declare class StoreSnapshotWrapper<State extends object> implements Store<State> {
    private snapshot;
    private onGetOrSet;
    private onGetAll;
    private subscribedFields;
    private isSubscribedToAllFields;
    constructor(snapshot: StoreSnapshot<State>, onGetOrSet: (key: keyof State) => void, onGetAll: () => void, subscribedFields: Partial<Record<keyof State, true>> | null, isSubscribedToAllFields: boolean);
    get<K extends keyof State>(key: K): State[K];
    set<K extends keyof State>(key: K): (value: State[K]) => void;
    on<K extends keyof State>(key: K): Observable<State[K]>;
    onAll(): Observable<Undux<State>[keyof State]>;
    getState(): Readonly<State>;
}
export declare type Options = {
    isDevMode: boolean;
};
/**
 * We create a single instance of this per <Container />.
 */
export declare class StoreDefinition<State extends object> implements Store<State> {
    private storeSnapshot;
    private alls;
    private emitter;
    private setters;
    constructor(state: State, options: Options);
    on<K extends keyof State>(key: K): Observable<State[K]>;
    onAll(): Observable<Undux<State>[keyof State]>;
    get<K extends keyof State>(key: K): State[K];
    set<K extends keyof State>(key: K): (value: State[K]) => void;
    getCurrentSnapshot(): StoreSnapshot<State>;
    toStore(): Store<State>;
    getState(): Readonly<State>;
}
/**
 * @deprecated Use `createConnectedStore` instead.
 */
export declare function createStore<State extends object>(initialState: State, options?: Options): StoreDefinition<State>;
export declare type Effects<State extends object> = (store: StoreDefinition<State>) => StoreDefinition<State>;
export declare type EffectsAs<States extends {
    [alias: string]: any;
}> = (stores: {
    [K in keyof States]: StoreDefinition<States[K]>;
}) => {
    [K in keyof States]: StoreDefinition<States[K]>;
};
/**
 * @deprecated Use `Effects` instead.
 */
export declare type Plugin<State extends object> = (store: StoreDefinition<State>) => StoreDefinition<State>;
export * from './plugins/withLogger';
export * from './plugins/withReduxDevtools';
export * from './react';
