import { Emitter } from 'typed-rx-emitter';
import { mapValues } from './utils';
const CYCLE_ERROR_MESSAGE = '[undux] Error: Cyclical dependency detected. '
    + 'This may cause a stack overflow unless you fix it. \n'
    + 'The culprit is the following sequence of .set calls, '
    + 'called from one or more of your Undux Effects: ';
/**
 * Immutable snapshot of the current store state. One StoreSnapshot per
 * StoreDefinition is usually alive at a time.
 */
export class StoreSnapshot {
    constructor(state, storeDefinition) {
        this.state = state;
        this.storeDefinition = storeDefinition;
    }
    get(key) {
        return this.state[key];
    }
    set(key) {
        return this.storeDefinition.set(key);
    }
    on(key) {
        return this.storeDefinition.on(key);
    }
    onAll() {
        return this.storeDefinition.onAll();
    }
    getState() {
        return Object.freeze(this.state);
    }
}
/**
 * Immutable edge from StoreSnapshot to a component that consumes it
 * via withStore(). We use it to keep track of which fields a consumer
 * reads from, so that we can improve performance by only subscribing
 * to those fields.
 */
export class StoreSnapshotWrapper {
    constructor(snapshot, onGetOrSet, onGetAll, subscribedFields, isSubscribedToAllFields) {
        this.snapshot = snapshot;
        this.onGetOrSet = onGetOrSet;
        this.onGetAll = onGetAll;
        this.subscribedFields = subscribedFields;
        this.isSubscribedToAllFields = isSubscribedToAllFields;
    }
    get(key) {
        // Get the most up to date version of the field if we failed to notice a subscription
        if (!this.isSubscribedToAllFields && (this.subscribedFields && !(key in this.subscribedFields))) {
            this.onGetOrSet(key);
            return this.snapshot['storeDefinition'].get(key);
        }
        return this.snapshot.get(key);
    }
    set(key) {
        this.onGetOrSet(key);
        return this.snapshot.set(key);
    }
    on(key) {
        return this.snapshot.on(key);
    }
    onAll() {
        return this.snapshot.onAll();
    }
    getState() {
        this.onGetAll();
        return this.snapshot.getState();
    }
}
let DEFAULT_OPTIONS = {
    isDevMode: false
};
/**
 * We create a single instance of this per <Container />.
 */
export class StoreDefinition {
    constructor(state, options) {
        let emitterOptions = {
            isDevMode: options.isDevMode,
            onCycle(chain) {
                console.error(CYCLE_ERROR_MESSAGE + chain.join(' -> '));
            }
        };
        // Initialize emitters
        this.alls = new Emitter(emitterOptions);
        this.emitter = new Emitter(emitterOptions);
        // Set initial state
        this.storeSnapshot = new StoreSnapshot(state, this);
        // Cache setters
        this.setters = mapValues(state, (v, key) => (value) => {
            let previousValue = this.storeSnapshot.get(key);
            this.storeSnapshot = new StoreSnapshot(Object.assign({}, this.storeSnapshot.getState(), { [key]: value }), this);
            this.emitter.emit(key, value);
            this.alls.emit(key, { key, previousValue, value });
        });
    }
    on(key) {
        return this.emitter.on(key);
    }
    onAll() {
        return this.alls.all();
    }
    get(key) {
        return this.storeSnapshot.get(key);
    }
    set(key) {
        return this.setters[key];
    }
    getCurrentSnapshot() {
        return this.storeSnapshot;
    }
    toStore() {
        return this.storeSnapshot;
    }
    getState() {
        return this.storeSnapshot.getState();
    }
}
/**
 * @deprecated Use `createConnectedStore` instead.
 */
export function createStore(initialState, options = DEFAULT_OPTIONS) {
    return new StoreDefinition(initialState, options);
}
export * from './plugins/withLogger';
export * from './plugins/withReduxDevtools';
export * from './react';
//# sourceMappingURL=index.js.map