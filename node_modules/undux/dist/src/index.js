"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var typed_rx_emitter_1 = require("typed-rx-emitter");
var utils_1 = require("./utils");
var CYCLE_ERROR_MESSAGE = '[undux] Error: Cyclical dependency detected. '
    + 'This may cause a stack overflow unless you fix it. \n'
    + 'The culprit is the following sequence of .set calls, '
    + 'called from one or more of your Undux Effects: ';
/**
 * Immutable snapshot of the current store state. One StoreSnapshot per
 * StoreDefinition is usually alive at a time.
 */
var StoreSnapshot = /** @class */ (function () {
    function StoreSnapshot(state, storeDefinition) {
        this.state = state;
        this.storeDefinition = storeDefinition;
    }
    StoreSnapshot.prototype.get = function (key) {
        return this.state[key];
    };
    StoreSnapshot.prototype.set = function (key) {
        return this.storeDefinition.set(key);
    };
    StoreSnapshot.prototype.on = function (key) {
        return this.storeDefinition.on(key);
    };
    StoreSnapshot.prototype.onAll = function () {
        return this.storeDefinition.onAll();
    };
    StoreSnapshot.prototype.getState = function () {
        return Object.freeze(this.state);
    };
    return StoreSnapshot;
}());
exports.StoreSnapshot = StoreSnapshot;
/**
 * Immutable edge from StoreSnapshot to a component that consumes it
 * via withStore(). We use it to keep track of which fields a consumer
 * reads from, so that we can improve performance by only subscribing
 * to those fields.
 */
var StoreSnapshotWrapper = /** @class */ (function () {
    function StoreSnapshotWrapper(snapshot, onGetOrSet, onGetAll, subscribedFields, isSubscribedToAllFields) {
        this.snapshot = snapshot;
        this.onGetOrSet = onGetOrSet;
        this.onGetAll = onGetAll;
        this.subscribedFields = subscribedFields;
        this.isSubscribedToAllFields = isSubscribedToAllFields;
    }
    StoreSnapshotWrapper.prototype.get = function (key) {
        // Get the most up to date version of the field if we failed to notice a subscription
        if (!this.isSubscribedToAllFields && (this.subscribedFields && !(key in this.subscribedFields))) {
            this.onGetOrSet(key);
            return this.snapshot['storeDefinition'].get(key);
        }
        return this.snapshot.get(key);
    };
    StoreSnapshotWrapper.prototype.set = function (key) {
        this.onGetOrSet(key);
        return this.snapshot.set(key);
    };
    StoreSnapshotWrapper.prototype.on = function (key) {
        return this.snapshot.on(key);
    };
    StoreSnapshotWrapper.prototype.onAll = function () {
        return this.snapshot.onAll();
    };
    StoreSnapshotWrapper.prototype.getState = function () {
        this.onGetAll();
        return this.snapshot.getState();
    };
    return StoreSnapshotWrapper;
}());
exports.StoreSnapshotWrapper = StoreSnapshotWrapper;
var DEFAULT_OPTIONS = {
    isDevMode: false
};
/**
 * We create a single instance of this per <Container />.
 */
var StoreDefinition = /** @class */ (function () {
    function StoreDefinition(state, options) {
        var _this = this;
        var emitterOptions = {
            isDevMode: options.isDevMode,
            onCycle: function (chain) {
                console.error(CYCLE_ERROR_MESSAGE + chain.join(' -> '));
            }
        };
        // Initialize emitters
        this.alls = new typed_rx_emitter_1.Emitter(emitterOptions);
        this.emitter = new typed_rx_emitter_1.Emitter(emitterOptions);
        // Set initial state
        this.storeSnapshot = new StoreSnapshot(state, this);
        // Cache setters
        this.setters = utils_1.mapValues(state, function (v, key) {
            return function (value) {
                var _a;
                var previousValue = _this.storeSnapshot.get(key);
                _this.storeSnapshot = new StoreSnapshot(Object.assign({}, _this.storeSnapshot.getState(), (_a = {}, _a[key] = value, _a)), _this);
                _this.emitter.emit(key, value);
                _this.alls.emit(key, { key: key, previousValue: previousValue, value: value });
            };
        });
    }
    StoreDefinition.prototype.on = function (key) {
        return this.emitter.on(key);
    };
    StoreDefinition.prototype.onAll = function () {
        return this.alls.all();
    };
    StoreDefinition.prototype.get = function (key) {
        return this.storeSnapshot.get(key);
    };
    StoreDefinition.prototype.set = function (key) {
        return this.setters[key];
    };
    StoreDefinition.prototype.getCurrentSnapshot = function () {
        return this.storeSnapshot;
    };
    StoreDefinition.prototype.toStore = function () {
        return this.storeSnapshot;
    };
    StoreDefinition.prototype.getState = function () {
        return this.storeSnapshot.getState();
    };
    return StoreDefinition;
}());
exports.StoreDefinition = StoreDefinition;
/**
 * @deprecated Use `createConnectedStore` instead.
 */
function createStore(initialState, options) {
    if (options === void 0) { options = DEFAULT_OPTIONS; }
    return new StoreDefinition(initialState, options);
}
exports.createStore = createStore;
__export(require("./plugins/withLogger"));
__export(require("./plugins/withReduxDevtools"));
__export(require("./react"));
//# sourceMappingURL=index.js.map